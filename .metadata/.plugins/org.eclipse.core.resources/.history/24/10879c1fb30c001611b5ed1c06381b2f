package com.mak.epi.bitmanipulation;


import com.mak.epi.exceptions.InvalidIndexException;

public class BitManipulation {
	private long value;

	public BitManipulation(long value){
		this.value= value;
	}

	public BitManipulation(){
		super();
	}

	public void setValue(long value){
		this.value=value;
	}

	public long getValue(){
		return this.value;
	}

	public long swapBits(int locA,int locB){
		//create temp value 
		long result= this.value;
		if(locA <0 | locB < 0)
			throw InvalidIndexException();
		// extract the bits in locA && locB
		// need to swap the bits only if they are not same
		// example let the number be 11101110 and locA & locB be  2 and 5
		// then 1L << locA = 10 1L<< locB = 10000  and ORing both the value = 00010
		// 11101110 ^ 00010010 = 111111100
		if(((result>>locA) & 1 )!= ((result>>locB) & 1)){
			//set the bitmask for both the locations and XOR against the original value
			result=result^((1L<<locA) | (1L << locB))
		}
		return result;
	}

}
